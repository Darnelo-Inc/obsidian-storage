## Что такое TCP соединение на самом деле

**TCP-соединение** — это абстракция, представляющая собой **надёжный двусторонний канал связи** между двумя устройствами в сети. Физически оно реализовано как **структура данных в памяти** операционной системы на каждой стороне соединения, содержащая информацию о состоянии связи. 

**Важно!** Обе стороны могут передавать друг другу данные.

![[Pasted image 20250921142908.png]]
![[Pasted image 20250921144940.png|1200]]
### Флаги (управляющие биты)

- **NS** (ECN-nonce) — Устойчивый механизм сигнализации насыщения с помощью ECN-nonce
- **CWR** (Congestion Window Reduced) — Поле «Окно перегрузки уменьшено» — флаг установлен отправителем, чтобы указать, что получен пакет с установленным флагом ECE
- **ECE** (ECN-Echo) — Поле «Эхо ECN» — указывает, что данный узел способен на ECN (явное уведомление перегрузки) и для указания отправителю о перегрузках в сети
- **URG** — поле _«Указатель важности»_ задействовано. Когда узел отправляет сегмент с URG флагом, то узел-получатель принимает его на отдельном канале.
- **ACK** — поле _«Номер подтверждения»_ задействовано
- **PSH** — инструктирует получателя протолкнуть данные, накопившиеся в приёмном буфере, в приложение пользователя. API для установки PSH флага нет. Обычно он устанавливается ядром, когда оно очищает буфер. Дело в том, что когда узел отправляет информацию, TCP сохраняет её в буфере и не передает её сразу другому узлу, ожидая, захочет ли узел-отправитель передать ещё. Такая же схема работает и у узла-получателя. Когда он получает информацию, TCP сохраняет её в буфере, чтобы не тревожить приложение из-за каждого байта полученной информации. Если узел отправляет сегмент с PSH флагом, это значит, что он отправил все, что было нужно.
- **RST** — оборвать соединения, сбросить буфер (очистка буфера)
- **SYN** — синхронизация номеров последовательности
- **FIN** — флаг, будучи установлен, указывает на завершение соединения

---
## Ключевые компоненты состояния TCP соединения

### 1. Структуры данных в ядре ОС

На каждой стороне (клиент и сервер) в памяти ядра хранится:

**TCP Control Block (TCB)** — структура, содержащая:

- IP-адреса и порты обеих сторон (составляют уникальный идентификатор соединения)
- Текущие порядковые номера (sequence numbers)
- Размеры окон (window sizes)
- Параметры буферов отправки и получения
- Таймеры и счетчики повторных передач
- Информация о состоянии соединения (LISTEN, SYN-SENT, ESTABLISHED и т.д.)

### 2. Буферы данных

- **Буфер отправки**: хранит данные, ожидающие отправки или подтверждения
- **Буфер приема**: хранит полученные данные, ожидающие обработки приложением

### 3. Таблицы состояний в ядре

- Операционная система поддерживает таблицы всех активных TCP соединений
- В Linux их можно увидеть с помощью команды netstat или ss

---
## Установление соединения: трехстороннее рукопожатие (SYN, SYN-ACK, ACK)

Это не просто "проверка" — это процесс синхронизации состояний и согласования параметров:

 **Шаг 1. Клиент отправляет SYN**

- Клиент генерирует случайный начальный sequence number (номер последовательности для передачи данных).
- Строится TCP-пакет с флагом SYN.
- В этом пакете может быть доп. служебная информация, например, размер receive window (сколько может принять).
- Пакет уходит серверу.


**Шаг 2. Сервер принимает SYN, отправляет SYN+ACK**

Когда сервер получает SYN, ОС делает следующее:

1. **Проверка ресурсов и лимитов**
   - Серверная ОС должна:
     - Проверить, не превышено ли системное ограничение на количество полуоткрытых соединений (backlog).
     - Впишется ли еще один полуоткрытый сокет в очередь SYN_RCVD.
   - **Если ресурсов недостаточно (например, нет RAM, превышен backlog) — сервер просто не ответит вообще SYN-ACK, или отправит RST.**  
  
   Это защита от атак типа “SYN-флуд”.

2. **Запись состояния (полуоткрытый сокет)**
   - Сервер создаёт временную структуру (полуоткрытый сокет в очереди SYN_RCVD).  
   - В памяти сервера создаётся запись, которая "ждёт" подтверждения (ACK) от клиента.

3. **Генерация server sequence number**
   - Сервер генерирует свой sequence number.

4. **Ответ клиенту**
   - Сервер строит TCP-пакет с флагами SYN и ACK.
   - В ACK поле указывается подтверждение client sequence number + 1.
   - SYN — обозначает, что сервер готов к соединению - сообщает свой начальный порядковый номер.


**Шаг 3. Клиент отправляет ACK**
- Клиент присылает подтверждение.
- Сервер получает ACK — вот теперь сервер _дорабатывает_ (переводит) полуоткрытый сокет в полноценный открытый сокет (ESTABLISHED) и добавляет его в таблицу открытых соединений. Теперь обе стороны могут передавать данные.

После этого в ОС обеих сторон создаются полноценные TCB-структуры, и соединение переходит в состояние ESTABLISHED.

---
## Что происходит при передаче данных

### 1. Нумерация и отслеживание байтов

- Каждый байт данных в TCP имеет свой порядковый номер
- Стороны отслеживают, какие данные были:
  - Отправлены, но не подтверждены
  - Подтверждены (ACK)
  - Потеряны и требуют повторной отправки

### 2. Механизм скользящего окна

- Определяет, сколько данных можно отправить до получения подтверждения
- Динамически регулируется в зависимости от загруженности сети
- Реализует управление потоком (flow control)

### 3. Алгоритмы управления перегрузкой

- Slow Start: начало с малого окна и быстрое увеличение
- Congestion Avoidance: плавное увеличение окна
- Fast Retransmit/Fast Recovery: быстрое восстановление при потере пакетов

### 4. Механизм подтверждений (ACK)

- Получатель отправляет ACK с номером следующего ожидаемого байта
- Селективные подтверждения (SACK) позволяют подтверждать отдельные блоки данных
- Вынужденное подтверждение (при нечетном кол-ве сегментов)

---

## Состояния соединения в виде конечного автомата

TCP-соединение в любой момент находится в одном из следующих состояний:

1. **CLOSED**: Начальное состояние (соединения нет)
2. **LISTEN**: Сервер ожидает входящие соединения
3. **SYN-SENT**: Клиент отправил SYN, ждет SYN-ACK
4. **SYN-RECEIVED**: Сервер получил SYN, отправил SYN-ACK, ждет ACK
5. **ESTABLISHED**: Соединение установлено, данные передаются
6. **FIN-WAIT-1**: Сторона инициировала закрытие, отправила FIN
7. **FIN-WAIT-2**: Получен ACK на FIN, ожидание FIN от другой стороны
8. **CLOSE-WAIT**: Получен FIN, но локальное приложение еще не закрыло соединение
9. **LAST-ACK**: Отправлен собственный FIN, ожидается ACK
10. **TIME-WAIT**: Четырехстороннее закрытие завершено, ожидание возможных дублированных пакетов
11. **CLOSING**: Обе стороны одновременно отправили FIN

![[Pasted image 20250921142503.png|900]]  

---
### 12 идей для понимания TCP

![[Pasted image 20251015070039.png|900]]

![[Pasted image 20251015070310.png|900]]
![[Pasted image 20251015070502.png|900]]
![[Pasted image 20251015070806.png|900]] 
![[Pasted image 20251015071151.png|900]]
![[Pasted image 20251015071443.png|900]]
![[Pasted image 20251015071832.png|900]]
![[Pasted image 20251015072045.png|900]]
![[Pasted image 20251015072600.png|900]]
![[Pasted image 20251015072803.png|900]]
![[Pasted image 20251015073213.png|900]]
![[Pasted image 20251015073417.png|900]]
![[Pasted image 20251015073703.png|900]]


---

###### Источники:

- [# КАК УСТРОЕН TCP/IP?](https://youtu.be/EJzitviiv2c?si=bTUNg8okt71QlA7e)
- [# TCP - 12 simple ideas to explain the Transmission Control Protocol](https://youtu.be/JFch3ctY6nE?si=9815WGLoJC6lYEBy)